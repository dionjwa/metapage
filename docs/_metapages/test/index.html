---
layout: vanilla
---

<!-- 
    This metapage is part of the functional test suite.
    It creates a metaframe for each existing version, and linking each
    metaframe with the next. The first metaframe gets some input, and
    concats the input array with its version and passes it to the next.
    At the end, the metapage should get a notification from the 
    last metaframe with all versions appended to the array.
 -->

<head></head>
<body style="background-color:yellow;">
    <div id='version'></div>
    <div id='status'>RUNNING TESTS...</div>
    <div id='body'></div>
</body>

<script>
// Download the specific metaPAGE library version
// to make it easier to test all versions against all
var urlParams = new URLSearchParams(window.location.search);
var VERSION = urlParams.get('VERSION');
{% if jekyll.environment == "production" %}
VERSION = VERSION == null ? '{{site.data.lib_versions.metapage}}' : VERSION;
{% else %}
VERSION = VERSION == null ? 'latest' : VERSION;
{% endif %}
document.getElementById('version').innerText = `Metapage version=${VERSION}`;
var head = document.getElementsByTagName('head').item(0);
var script = document.createElement('script');
script.setAttribute('type', 'text/javascript');
if (VERSION == 'latest') {
    script.setAttribute('src', `/js/metapage/browser.js`);
} else {
    script.setAttribute('src', `https://cdn.jsdelivr.net/npm/metapage@${VERSION}/browser.js`);
}
head.appendChild(script);

window.onload = function() {

    //TODO generate this dynamically 
    const metaPageDefinition = {
        version: "{{site.data.lib_versions.all.last}}",
        metaframes: {},
    };

    // The metaframes are arranged in a line, latest first
    // each will pass the next a data blob. At the end the
    // metapage will verify that all metaframes added their versions
    const VERSIONS_METAFRAME = [];
{% if jekyll.environment != "production" %}
    VERSIONS_METAFRAME.push('latest');
{% endif %}
{% for v in site.data.lib_versions.all %}
    VERSIONS_METAFRAME.push("{{v}}");
{% endfor %}

    console.log('metaframe versions', VERSIONS_METAFRAME);
    
    VERSIONS_METAFRAME.forEach((versionMetaframe, index) => {
        // const url = `{{site.url}}/metaframes/test/?VERSION=${versionMetaframe}`;
        const url = `/metaframes/test/?VERSION=${versionMetaframe}`;
        metaPageDefinition.metaframes[versionMetaframe] = {"url": url};
        if (index > 0) {
            metaPageDefinition.metaframes[versionMetaframe].inputs = [
                {
                    metaframe: VERSIONS_METAFRAME[index - 1],
                    source: 'output',
                    target: 'input',
                }
            ]
        }
    });

    console.log(JSON.stringify(metaPageDefinition, null, '  '));

    var metapage = Metapage.from(metaPageDefinition);

    // Ensure all metaframes can send inputs
    var promises = [];
    metapage.metaframeIds().forEach((metaframeId) => {
        promises.push(new Promise((resolve, reject) => {
            const metaframe = metapage.get(metaframeId);
            let hasSendTestInputsFromMetaframe = false;
            metaframe.onInputs((inputs) => {
                // console.log('metaframe inputs', inputs);
                if (!hasSendTestInputsFromMetaframe) {
                    if (inputs['save-input-check']) {
                        hasSendTestInputsFromMetaframe = true;
                        if (inputs['save-input-check'] == metaframeId) {
                            resolve(true);
                        } else {
                            reject(`'save-input-check' != '${metaframeId}'`);
                        }
                    }
                }
            });
        }));
    });

    // Look to the outputs of the LAST metaframe
    promises.push(new Promise((resolve, reject) => {
        const lastMetaframe = metapage.get(VERSIONS_METAFRAME[VERSIONS_METAFRAME.length - 1]);
        let hasFinalOutputs = false
        lastMetaframe.onOutputs((outputs) => {
            if (outputs['output']) {
                hasFinalOutputs = true;
                const finalVersions = outputs['output'].versions;
                if (JSON.stringify(VERSIONS_METAFRAME) == JSON.stringify(finalVersions)) {
                    resolve(true);
                } else {
                    reject(`VERSIONS_METAFRAME(${JSON.stringify(VERSIONS_METAFRAME)}) != finalVersions('${finalVersions})'`);
                }
            }
        });
    }));



    
    var iframes = metapage.iframes();
    // Add the metaframe iframes to the page
    for (var key in iframes) {
        var div = document.createElement("div");
        div.appendChild(iframes[key]);
        document.getElementById("body").appendChild(div);
    }

    // Start the train. Metaframes will add their version to the
    // array and pass it on
    metapage.setInput({
        latest: {
            input: {
                versions:[]
            }
        }
    });

    Promise.all(promises)
        .then(() => {
            document.body.style.backgroundColor = "green";
            document.getElementById('status').innerText = "METAPAGE TESTS PASS!";
        })
        .catch((err) => {
            document.body.style.backgroundColor = "red";
            document.getElementById('status').innerHTML = "METAPAGE TESTS FAIL:<br/>" + err;
        })
};

</script>
