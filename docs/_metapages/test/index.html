---
layout: vanilla
---

<!-- 
    This metapage is part of the functional test suite.
    It creates a metaframe for each existing version, and linking each
    metaframe with the next. The first metaframe gets some input, and
    concats the input array with its version and passes it to the next.
    At the end, the metapage should get a notification from the 
    last metaframe with all versions appended to the array.
 -->

<head>
    <script src="https://cdn.jsdelivr.net/npm/compare-versions@3.4.0/index.js"></script>
</head>
<body style="background-color:yellow;">
    <div id='version'></div>
    <div id='status'>RUNNING TESTS...</div>
    <div id='body'></div>
</body>

<script>
// Download the specific metaPAGE library version
// to make it easier to test all versions against all
var urlParams = new URLSearchParams(window.location.search);
var VERSION = urlParams.get('VERSION');
{% if jekyll.environment == "production" %}
VERSION = VERSION == null ? '{{site.data.versions.versions.last}}' : VERSION;
{% else %}
VERSION = VERSION == null ? 'latest' : VERSION;
{% endif %}
document.getElementById('version').innerText = `Metapage version=${VERSION}`;
var head = document.getElementsByTagName('head').item(0);
var script = document.createElement('script');
script.setAttribute('type', 'text/javascript');
if (VERSION == 'latest') {
    script.setAttribute('src', `/js/metapage/browser.js`);
} else {
    script.setAttribute('src', `https://cdn.jsdelivr.net/npm/metapage@${VERSION}/browser.js`);
}
head.appendChild(script);

const convertNpmToInternalVersion = (version) => {
    if (version == 'latest') {
        // This file gets updated when the version is bumped
        // return "{{site.data.versions.versions.last}}";
        return Metapage.getLibraryVersionMatching(version);
    // use the internal version matching code
    } else if (window.compareVersions(version, '0.2') > 0) {
        return Metapage.getLibraryVersionMatching(version);
    // otherwise the above logic wasn't yet implemented, so we have to do it here (versioning lessons)
    } else if (window.compareVersions(version, '0.2') >= 0) {
        return '0.2';
    } else {
        return '0.1.0';
    }
}



window.onload = function() {
    console.log('Metapage', convertNpmToInternalVersion(VERSION));
    //TODO generate this dynamically 
    const metaPageDefinition = {
        version: convertNpmToInternalVersion(VERSION),
    };

    const metaframesBlob = {};

    // AHHH version differences
    if (VERSION != 'latest' && window.compareVersions(VERSION, '0.2') < 0) {
        metaPageDefinition.iframes = metaframesBlob;
    } else {
        metaPageDefinition.metaframes = metaframesBlob;
    }

    // The metaframes are arranged in a line, latest first
    // each will pass the next a data blob. At the end the
    // metapage will verify that all metaframes added their versions
    const VERSIONS_METAFRAME = [];


{% for v in site.data.versions.versions %}
    VERSIONS_METAFRAME.push("{{v}}");
{% endfor %}
{% if jekyll.environment != "production" %}
    // Test the current version inputs *and* outputs
    VERSIONS_METAFRAME.unshift('latestFirst');
    VERSIONS_METAFRAME.push('latest');
{% endif %}
    console.log('VERSIONS_METAFRAME', VERSIONS_METAFRAME);
    
    VERSIONS_METAFRAME.forEach((versionMetaframe, index) => {
        // const url = `{{site.url}}/metaframes/test/?VERSION=${versionMetaframe}`;
        const url = `/metaframes/test/?VERSION=${versionMetaframe.startsWith('latest') ? 'latest' : versionMetaframe}`;
        versionMetaframe = versionMetaframe == 'latest' && index == 0 ? 'latestFirst' : versionMetaframe;
        metaframesBlob[versionMetaframe] = {"url": url};
        if (index > 0) {
            metaframesBlob[versionMetaframe].inputs = [
                {
                    metaframe: VERSIONS_METAFRAME[index - 1],
                    source: 'output',
                    target: 'input',
                }
            ]
        }
    });

    console.log(JSON.stringify(metaPageDefinition, null, '  '));

    var metapage = Metapage.from(metaPageDefinition);

    // Ensure all metaframes can send inputs
    var promises = [];
    metapage.metaframeIds().forEach((metaframeId) => {
        promises.push(new Promise((resolve, reject) => {
            const metaframe = metapage.get(metaframeId);
            let hasSendTestInputsFromMetaframe = false;
            metaframe.onInputs((inputs) => {
                // console.log('metaframe inputs', inputs);
                if (!hasSendTestInputsFromMetaframe) {
                    if (inputs['save-input-check']) {
                        hasSendTestInputsFromMetaframe = true;
                        if (inputs['save-input-check'] == metaframeId) {
                            resolve(true);
                        } else {
                            reject(`'save-input-check' != '${metaframeId}'`);
                        }
                    }
                }
            });
        }));
    });

    // Look to the outputs of the LAST metaframe
    promises.push(new Promise((resolve, reject) => {
        const lastMetaframe = metapage.get(VERSIONS_METAFRAME[VERSIONS_METAFRAME.length - 1]);
        let hasFinalOutputs = false;
        console.log('VERSIONS_METAFRAME[VERSIONS_METAFRAME.length - 1]', VERSIONS_METAFRAME[VERSIONS_METAFRAME.length - 1]);
        console.log('lastMetaframe', lastMetaframe);
        lastMetaframe.onOutputs((outputs) => {
            if (outputs['output']) {
                hasFinalOutputs = true;
                let finalVersions = outputs['output'].versions;
                // Correct for needing 'latest' twice but not using the key 'latest' twice
                const versionsTested = VERSIONS_METAFRAME.map(e => e.replace('latestFirst', 'latest'));
                if (JSON.stringify(versionsTested) == JSON.stringify(finalVersions)) {
                    resolve(true);
                } else {
                    reject(`versionsTested(${JSON.stringify(versionsTested)}) != finalVersions('${finalVersions})'`);
                }
            }
        });
    }));
    
    var iframes = metapage.iframes();
    // Add the metaframe iframes to the page
    for (var key in iframes) {
        var div = document.createElement("div");
        div.appendChild(iframes[key]);
        document.getElementById("body").appendChild(div);
    }

    // Start the train. Metaframes will add their version to the
    // array and pass it on
    const inputs = {};
    inputs[VERSIONS_METAFRAME[0]] = {input: {versions:[]}};

    metapage.setInput(inputs);

    Promise.all(promises)
        .then(() => {
            document.body.style.backgroundColor = "green";
            document.getElementById('status').innerText = "METAPAGE TESTS PASS!";
        })
        .catch((err) => {
            document.body.style.backgroundColor = "red";
            document.getElementById('status').innerHTML = "METAPAGE TESTS FAIL:<br/>" + err;
        })
};

</script>
